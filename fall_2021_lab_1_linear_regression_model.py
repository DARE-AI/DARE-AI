# -*- coding: utf-8 -*-
"""Fall 2021 - Lab 1 -   Linear Regression Model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mV4Ftl3EsCk7xQheMvPmwihjLC5GewkA

#### Copyright 2021 .. Authors

```
# This is formatted as code
```

.

#Training, testing/validation and inferencing
"""

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""#Lab 1: Training Your Linear Regression Model
> Visualize the data, the learned model, and how the loss is evolving during training. Learn how to set up the features in TensorFlow to train a model.
Use the polyfit class in TensorFlow to predict a real-valued featured based on one real-valued input feature. Evaluate the accuracy of a model's predictions using Root Mean Squared Error (RMSE).

```
Run each cell or Run all to execute the code. Understand this lab and complete the tasks given at the end of this lab

```

## 1. Learning in Linear Regression Model

### Imports
In this first cell, we'll import some libraries, including  [Pandas](http://pandas.pydata.org/), which is a package we use for reading in our data, exploring our data and doing some basic processing.
"""

import math
import tensorflow as tf

from IPython import display
from matplotlib import cm
from matplotlib import gridspec
from matplotlib import pyplot as plt
import numpy as np
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D
from sklearn import metrics
from time import time as epoc
import tensorflow.compat.v1 as tf
tf.disable_v2_behavior() # we could disable 2 TFv2 
print("Done with the imports.")

"""### Data Set
This lab will use a data set from one example covered in the class
"""

# training data (input and output) for bike renting based on temperature of the day
x_train = [55, 60, 68,71,76,82]   #Temp in ° F
y_train =[117, 126, 138, 142, 150, 156]  # bikes rented out

"""### Using a Scatter Plot to Visualize the Data

We will begin by trying to predict the price using the horsepower.  Because we just have a single feature we can visualize the raw data using a scatter plot.
"""

# Visualization of data (input and output) for bike renting based on temperature of the day
plt.scatter(x_train,y_train, c='red')
plt.ylabel("Bicycle rentals")
plt.xlabel("Temperature")
plt.show()

"""###Using Numpy polyfit to Find the Line that Minimizes RMSE
For the task of finding a line that minimizes the squared error with respect to a set of points, using SGD is not the most efficient method but it will be useful in that it can be applied to much more complex problems.  As a tool to help see what the optimal solution looks like we wil use `polyfit` to compute the optimal solution and then add that to our plot.
"""

# Training based on training data (input and output) for bike renting based on temperature of the day
x = x_train
y = y_train
opt = np.polyfit(x, y, 1)
y_pred = int(opt[0]) * x + opt[1]
opt_rmse = math.sqrt(metrics.mean_squared_error(y_pred, y))
slope = opt[0]
bias = opt[1]
print("Optimal Training RMSE =", opt_rmse, "for solution", opt)

"""###Visualizing a Linear Model Using a Scatter Plot

When training a linear regression model over a single variable, a really nice thing to be able to do is to show the model (which is just a line) as part of the scatter plot. That really helps you see how well the model fits the data. Just looking at the loss (RMSE here) doesn't really indicate how good the model is. Sometimes you want to show several models on the same scatter plot to compare them so we allow slopes, biases, and model_names to all be lists. They should be of the same size giving the weight (slope), bias, and name (to use in the legend) for the model.
"""

# Function to find the linear model based on the traiiing on training data (input and output) for bike renting based on temperature of the day

def scatter_plot(features, targets, slopes=[], biases=[], model_names=[]):
  """ Creates a scatter plot of input_feature vs target along with the models.
  Args:
    features: list of the input features
    targets: list of targets
    slopes: list of model weight (slope) 
    bias: list of model bias (same size as slopes)
    model_names: list of model_names to use for legend (same size as slopes)
  """      
  # Define some colors to use that go from blue towards red
  colors = [cm.coolwarm(x) for x in np.linspace(0, 1, len(slopes))]
  
  # Generate the Scatter plot
  plt.ylabel("# of Bicycle Renting")
  plt.xlabel("Temp (F)")
  plt.scatter(features, targets, color='red', label=" Training data")
  
  # Add the lines corresponding to the provided models
  for i in range (0, len(slopes)):
    y_0 = slopes[i] * min(features) + biases[i]
    y_1 = slopes[i] * max(features) + biases[i]
    plt.plot([min(features), max(features)], [y_0, y_1],
             label=model_names[i], color=colors[i])
  if (len(model_names) > 0):
    plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)

scatter_plot(x_train, y_train, 
             [slope], [bias], ["Optimal model"])

"""##2. Validation of the learned model 
Validation of learned model with validation data and finding the validation errors and its comparison with training error
"""

x_vald= [53, 62,68,73,80]
y_vald = [114, 130,135, 147, 154]

y_vald_pred = int(slope) *x_vald+ bias
validation_rmse = math.sqrt(metrics.mean_squared_error(y_vald_pred,y_vald))
print("Valication RMSE =", validation_rmse, "for solution", opt)
print("Training RMSE =", opt_rmse, "for solution", opt)
print("Valication RMSE and Trainig RMSE error % =", abs(validation_rmse -opt_rmse)/opt_rmse *100)

"""##3. Inferencing/Prediction
For inferencing by using learned model 
"""

#@title Inferencing/Predicting for 
X_New =  85#@param {type:"number"}

init = tf.compat.v1.global_variables_initializer()

with tf.compat.v1.Session() as sess2:
  sess2.run(init)
  # New Value 
  x_i = tf.compat.v1.placeholder(tf.float32)
  curr_W = slope
  curr_b = bias
  YY= curr_W *x_i + curr_b 
  Y_NEW = sess2.run(YY, {x_i: X_New})
  print("For", X_New,"°F, the expected number of bicycles to be rented is =", int(Y_NEW))

"""=============================================

#Exercise (Tasks to be completed)

**Develop a learning, validation and inferencing model for predicting temperature based on Cricket Chirp rate. You can use any data source that you have or use the following source**


Sample data and sample code can be found at [HERE](https://colab.research.google.com/drive/1jsuVhBXH5a8na5fWmghykrr6wy7l6iG9#scrollTo=Y2tRs2U5qv5M)

*italicized text*
Sample Data for the Cricket chirp rate vs temperature can be found in the following link 
https://www.globe.gov/explore-science/scientists-blog/archived-posts/sciblog/index.html_p=45.html
"""